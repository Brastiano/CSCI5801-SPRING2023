***
Project 1: Waterfall Methodology  
Authors: Andrew Brevick, Brian Bianchi, Cuong Ha  
Course: CSCI 5801 (001) - Spring 2023  
***
Last update to this document: 03/26/2023
***
**1. DESCRIPTION**  
In this project, we are creating a program that reads and handles the election results from a
given input file. The program will first determine what type the election is: Instant Runoff (IR)
or Close Party List (CPL). Based on the election type, the program will have different algorithms
to handle the calculations to determine who the winner or winners will be (IR), or to determine how
many seats each of the political parties will be receiving by the end of election.

**2. ABOUT THE PROGRAM**  
The program is created to be runnable in two different modes: Command Line Interface (CLI) and
Graphical User Interface (GUI). We will be using Makefile to create the executables and run them.
Compiled executables can also be run with input parameters of "date" and "input_file_name" to expedite
the process.

**3. IMPORTANT NOTE TO EVERYONE (PLEASE READ CAREFULLY BEFORE DOING ANYTHING ELSE)**  
The authors are well aware of the fact that the code for GUI mode cannot, at the time of submission,
be compiled on the CSE lab machine of the University of Minnesota, Twin Cities. The reason for that
is because the GUI was written entirely using the package `gtkmm-3.0-dev`, which is something that
CSE lab machines do not have (again, at the time of submission). Therefore, it is **NOT** recommended
to recompile the code for the GUI, delete the existing executable `Tabulator_GUI`, or do anything
that might make changes to the GUI executable because it will not be reproducible on the CSE lab machine.
The standard mode with the CLI functions without regard to the GUI and can be compiled and run on
CSE lab machines. See below for the instructions on doing that. For more information on the GUI issue,
see Section 8: "FINAL GUI NOTES".

**4. HOW TO USE MAKEFILE**  
To simplify things, we have added some command lines to Makefile to support the development process,
as well as to support the grading process. We will leave everything related to GUI mode at the end
of this list:
1. `make` or `make all`: This will compile all the source files in `src` directory and generate an
executable for CLI mode, which can later be opened to run the program in CLI mode.
2. `make time`: This serves the same purpose as `make` or `make all` with additional command for
determining how long it takes for the program to finish executing, including the time to take user
input.
3. `make run`: This can be called after `make` or `make all` in order to run the program in CLI mode.
4. `make clean`: This will erase all the generated object files and executable for CLI mode, as well
as clear the terminal.
5. `make docs`: This will use Doxygen to document all the files in `src` directory.
6. `make gui`: This will compile all the source files in `src` directory and generate an
executable for GUI mode, which can later be opened to run the program in GUI mode.
7. `make run_gui`: This can be called after `make gui` in order to run the program in GUI mode.
8. `make clean_gui`: This will erase all the generated object files and executable for GUI mode, as well
as clear the terminal.

*Note #1: All the Makefile commands must be done inside `Project1` directory and not its subdirectories*  
*Note #2: An executable generated by `make`, `make all`, `make gui` is also inside `Project1` directory* 

**5. WHAT IS EXPECTED AFTER THE PROGRAM FINISHES**  
After the program is finished, the interface will print out the results of the election in a very
simple manner. An audit file with the name format `audit_file_<voting_method>_<date>.txt` should
be created in the directory `Project1` with much more detailed information.

**6. DOCUMENTATION**  
All the documentation for the source code will be inside `documentation` directory. The documentation
can be viewed by opening `index.html` under the directory `documentation/html`.

**7. TESTING**  
All of the code for unit tests, test datasets, and testing logs are placed in `testing` directory.

**8. FINAL GUI NOTES**  
We were aware of the requirements from the beginning that all code must be compilable and runnable on the
CSE lab machines. We researched the best options for creating a Linux based GUI and settled on `GTKMM` for
our project being the best, followed by `GTK+`. `GTKMM` is a C++ wrapper for the C library `GTK+`, which would
make it the easiest and cleanest to integrate with the rest of our project. From there, we searched the
lab machine package library to identify if the `GTKMM` package was present to allow us to utilize the library;
we found two: `libgtkmm-2.4-1v5` and `libgtkmm-3.0-1v5`. We then installed those packages on our system, not
realizing (as there was little to nothing documenting this) that those packages are only for running `GTKMM`
software, not for compiling it, and that installing `GTKMM` locally on our machines automatically installed
the package `libgtkmm-3.0-dev` which inclues the development compilation tools. When debugging why our GUI
would not compile on the lab machines, we eventually found a passing description of the packages on a Ubuntu
package database which vaugely describes each. The descirption for the `dev` package did indicate that it had
compiler tools while the other did not. It was otherwise not very clear that the `dev` package was not just
representitive of the "latest" build of `GTKMM`. To accommodate this, we set compiler flags up with the Makefile
to allow a build dependent on `libgtkmm-3.0-dev` to be built and one that is not, as described above. We have
submitted a support request to the CSE labs staff, and it is possible that the `dev` package may be added by the
time of grading, which is part of why it is included here.
